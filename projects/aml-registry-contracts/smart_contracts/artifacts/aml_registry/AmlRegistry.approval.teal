#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 2 1 8
    bytecblock 0x151f7c75 0x5f69706673
    // smart_contracts/aml_registry/contract.py:15
    // class AmlRegistry(ARC4Contract):
    txn NumAppArgs
    bz main___algopy_default_create@15
    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert
    pushbytess 0xda43a819 0x54bdce30 0x5af6c04a 0xd181ad87 0xb91f63fd 0x41d37e43 0xc8858da0 0x02bece11 // method "register_wallet(byte[],uint64,uint64,uint64,string)string", method "update_risk_score(byte[],uint64)string", method "get_risk_profile(byte[])(uint64,uint64,uint64,uint64,uint64,uint64)", method "get_ipfs_hash(byte[])string", method "flag_wallet(byte[])string", method "is_wallet_flagged(byte[])uint64", method "get_risk_score(byte[])uint64", method "hello(string)string"
    txna ApplicationArgs 0
    match register_wallet update_risk_score get_risk_profile get_ipfs_hash flag_wallet is_wallet_flagged get_risk_score hello
    err

main___algopy_default_create@15:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return


// smart_contracts.aml_registry.contract.AmlRegistry.register_wallet[routing]() -> void:
register_wallet:
    // smart_contracts/aml_registry/contract.py:22
    // @abimethod
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_1 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 5
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_1 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/aml_registry/contract.py:44-45
    // # Validate risk score is in range
    // assert risk_score <= 100, "Risk score must be between 0 and 100"
    dig 3
    pushint 100
    <=
    assert // Risk score must be between 0 and 100
    // smart_contracts/aml_registry/contract.py:47-48
    // # Create wallet risk profile
    // is_flagged_value = UInt64(1) if risk_score >= 70 else UInt64(0)
    dig 3
    pushint 70
    >=
    // smart_contracts/aml_registry/contract.py:54
    // last_updated=Global.latest_timestamp,
    global LatestTimestamp
    // smart_contracts/aml_registry/contract.py:56
    // ipfs_hash_length=ipfs_hash.bytes.length,
    dig 2
    len
    // smart_contracts/aml_registry/contract.py:50-57
    // profile = WalletRiskProfile(
    //     risk_score=risk_score,
    //     transaction_count=transaction_count,
    //     flagged_connections=flagged_connections,
    //     last_updated=Global.latest_timestamp,
    //     is_flagged=is_flagged_value,
    //     ipfs_hash_length=ipfs_hash.bytes.length,
    // )
    uncover 6
    itob
    uncover 6
    itob
    concat
    uncover 5
    itob
    concat
    uncover 2
    itob
    concat
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/aml_registry/contract.py:59-60
    // # Store profile in box storage (key: hashed_id)
    // op.Box.put(hashed_id, profile.bytes)
    dig 2
    swap
    box_put
    // smart_contracts/aml_registry/contract.py:62-63
    // # Store IPFS hash in a separate box (key: hashed_id + "_ipfs")
    // ipfs_key = op.concat(hashed_id, Bytes(b"_ipfs"))
    swap
    bytec_1 // 0x5f69706673
    concat
    // smart_contracts/aml_registry/contract.py:64
    // op.Box.put(ipfs_key, ipfs_hash.bytes)
    swap
    box_put
    // smart_contracts/aml_registry/contract.py:22
    // @abimethod
    pushbytes 0x151f7c75003d57616c6c657420666c6167676564202d20536f756c20426f756e6420546f6b656e206372656174656420776974682049504653207265666572656e6365
    log
    intc_2 // 1
    return


// smart_contracts.aml_registry.contract.AmlRegistry.update_risk_score[routing]() -> void:
update_risk_score:
    // smart_contracts/aml_registry/contract.py:68
    // @abimethod
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_1 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    dup
    btoi
    // smart_contracts/aml_registry/contract.py:77
    // assert new_risk_score <= 100, "Risk score must be between 0 and 100"
    dup
    pushint 100
    <=
    assert // Risk score must be between 0 and 100
    // smart_contracts/aml_registry/contract.py:79-80
    // # Retrieve existing profile
    // profile_bytes, _exists = op.Box.get(hashed_id)
    dig 2
    box_get
    pop
    // smart_contracts/aml_registry/contract.py:83-84
    // # Update risk score and flag status
    // profile.risk_score = new_risk_score
    uncover 2
    replace2 0
    // smart_contracts/aml_registry/contract.py:85
    // profile.is_flagged = UInt64(1) if new_risk_score >= 70 else UInt64(0)
    swap
    pushint 70
    >=
    itob
    replace2 32
    // smart_contracts/aml_registry/contract.py:86
    // profile.last_updated = Global.latest_timestamp
    global LatestTimestamp
    itob
    replace2 24
    // smart_contracts/aml_registry/contract.py:88-89
    // # Save updated profile
    // op.Box.put(hashed_id, profile.bytes)
    box_put
    // smart_contracts/aml_registry/contract.py:68
    // @abimethod
    pushbytes 0x151f7c7500125269736b2073636f72652075706461746564
    log
    intc_2 // 1
    return


// smart_contracts.aml_registry.contract.AmlRegistry.get_risk_profile[routing]() -> void:
get_risk_profile:
    // smart_contracts/aml_registry/contract.py:93
    // @abimethod
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_1 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/aml_registry/contract.py:98
    // profile_bytes, _exists = op.Box.get(hashed_id)
    box_get
    pop
    // smart_contracts/aml_registry/contract.py:93
    // @abimethod
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return


// smart_contracts.aml_registry.contract.AmlRegistry.get_ipfs_hash[routing]() -> void:
get_ipfs_hash:
    // smart_contracts/aml_registry/contract.py:101
    // @abimethod
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_1 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/aml_registry/contract.py:109
    // ipfs_key = op.concat(hashed_id, Bytes(b"_ipfs"))
    bytec_1 // 0x5f69706673
    concat
    // smart_contracts/aml_registry/contract.py:110
    // ipfs_hash_bytes, _exists = op.Box.get(ipfs_key)
    box_get
    pop
    // smart_contracts/aml_registry/contract.py:101
    // @abimethod
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return


// smart_contracts.aml_registry.contract.AmlRegistry.flag_wallet[routing]() -> void:
flag_wallet:
    // smart_contracts/aml_registry/contract.py:113
    // @abimethod
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_1 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    dup
    // smart_contracts/aml_registry/contract.py:118
    // profile_bytes, _exists = op.Box.get(hashed_id)
    box_get
    pop
    // smart_contracts/aml_registry/contract.py:121-122
    // # Set flag to true
    // profile.is_flagged = UInt64(1)
    intc_2 // 1
    itob
    replace2 32
    // smart_contracts/aml_registry/contract.py:123
    // profile.last_updated = Global.latest_timestamp
    global LatestTimestamp
    itob
    replace2 24
    dup
    // smart_contracts/aml_registry/contract.py:125-126
    // # If not already high risk, set to 70 (flagged threshold)
    // if profile.risk_score < 70:
    intc_0 // 0
    extract_uint64
    pushint 70
    <
    bz flag_wallet_after_if_else@3
    // smart_contracts/aml_registry/contract.py:127
    // profile.risk_score = UInt64(70)
    pushint 70
    itob
    replace2 0

flag_wallet_after_if_else@3:
    // smart_contracts/aml_registry/contract.py:129
    // op.Box.put(hashed_id, profile.bytes)
    dig 1
    swap
    box_put
    // smart_contracts/aml_registry/contract.py:113
    // @abimethod
    pushbytes 0x151f7c75001d57616c6c657420666c616767656420666f7220414d4c20726576696577
    log
    intc_2 // 1
    return


// smart_contracts.aml_registry.contract.AmlRegistry.is_wallet_flagged[routing]() -> void:
is_wallet_flagged:
    // smart_contracts/aml_registry/contract.py:133
    // @abimethod
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_1 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/aml_registry/contract.py:139
    // profile_bytes, _exists = op.Box.get(hashed_id)
    box_get
    pop
    // smart_contracts/aml_registry/contract.py:141
    // return profile.is_flagged
    extract 32 8
    // smart_contracts/aml_registry/contract.py:133
    // @abimethod
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return


// smart_contracts.aml_registry.contract.AmlRegistry.get_risk_score[routing]() -> void:
get_risk_score:
    // smart_contracts/aml_registry/contract.py:143
    // @abimethod
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_1 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/aml_registry/contract.py:148
    // profile_bytes, _exists = op.Box.get(hashed_id)
    box_get
    pop
    // smart_contracts/aml_registry/contract.py:150
    // return profile.risk_score
    extract 0 8
    // smart_contracts/aml_registry/contract.py:143
    // @abimethod
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return


// smart_contracts.aml_registry.contract.AmlRegistry.hello[routing]() -> void:
hello:
    // smart_contracts/aml_registry/contract.py:152
    // @abimethod
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_1 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/aml_registry/contract.py:157
    // return String("Hello, ") + name
    pushbytes "Hello, "
    swap
    concat
    // smart_contracts/aml_registry/contract.py:152
    // @abimethod
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return
